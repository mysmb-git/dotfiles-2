#-----------------------------------------------------------------------------
typeset -g -A __git_theme=(
  prefix "("
  suffix ")"
  separator "|"
  branch "%{$reset_color%}%{$fg_bold[magenta]%}"
  clean "%{$reset_color%}%{$fg_bold[green]%}%{✔%G%}"
  changed "%{$reset_color%}%{$fg[blue]%}%{✚%G%}"
  staged "%{$reset_color%}%{$fg[red]%}%{●%G%}"
  conflicts "%{$reset_color%}%{$fg[red]%}%{✖%G%}"
  oid "%{$reset_color%}%{$fg[gray]%}"
  ahead "%{$reset_color%}%{↑%G%}"
  behind "%{$reset_color%}%{↓%G%}"
  untracked "%{$reset_color%}%{…%G%}"
  show_changed_count 1
  show_staged_count 1
  show_conflict_count 1
  show_ahead_count 1
  show_behind_count 1
  show_untracked_count 0
)
typeset -g -A __git_status
#-----------------------------------------------------------------------------
build_git_status() {
  (( $+commands[git] )) || return
  local _git_command="${1:=git}"
  [[ -z "${__git_status[$_git_command]}" ]] && return
  eval "$__git_status[$_git_command]"

  (( g[no_repository] == 1 )) && return

  function __print() {
    local theme="${__git_theme[$1]}"
    local show="${__git_theme[show_${1}_count]}"
    local value="${g[$1]}"

    [[ -z "$theme" ]] && return
    [[ "${show:=1}" == "1" ]] || return
    [[ "$value" == "0" ]] && return
    echo -n "$theme"

    [[ -z "$value" || "$value" == "yes_but_no_value_to_show" ]] && return
    echo -n "$value"
  }

  for element in prefix branch behind ahead separator oid separator staged conflicts changed untracked clean suffix ; do
    __print $element
  done

  echo -n "%{${reset_color}%}"
}
#-----------------------------------------------------------------------------
_prompt_update_git() {
  (( $+commands[git] )) || return
  local _git_command="${1:=git}"

  typeset -A g=(staged 0 conflicts 0 changed 0 untracked 0 ignored 0 no_repository 0 clean 0)

  while read -rA _status ; do
    case "${_status[1]}" in
      fatal*)
        g[no_repository]=1
        ;;
      \#)
        case "${_status[2]}" in
          branch.oid)
            g[oid]="${_status[3]:0:8}"
            ;;
          branch.head)
            g[branch]="${_status[3]}"
            ;;
          branch.upstream)
            g[upstream]="${_status[3]}"
            ;;
          branch.ab)
            g[ahead]=$((${_status[3]}))
            g[behind]=$((${_status[4]}))
            ;;
        esac
        ;;
      \?)
        (( g[untracked]++ ))
        ;;
      \!)
        (( g[ignored]++ ))
        ;;
      1)
        case "${_status[2]}" in
          .M)
            (( g[changed]++ ))
            ;;
          A.|M.)
            (( g[staged]++ ))
            ;;
        esac
        ;;
      2)
        case "${_status[2]}" in
          R.)
            (( g[changed]++ ))
            ;;
        esac
        ;;
    esac
  done < <($_git_command status --porcelain=2 --branch 2>&1)

  if (( g[changed] == 0 && g[conflicts] == 0 && g[staged] == 0 && g[untracked] == 0 )) ; then
    g[clean]="yes_but_no_value_to_show"
  fi

  __git_status[$_git_command]="$(typeset -p g)"
}
#-----------------------------------------------------------------------------
# vim: set syntax=zsh ft=zsh sw=2 ts=2 expandtab:
